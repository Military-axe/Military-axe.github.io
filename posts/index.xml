<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Mi1itray.axe</title>
    <link>http://localhost:1313/posts/</link>
    <description>Recent content in Posts on Mi1itray.axe</description>
    <generator>Hugo 0.125.1</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 30 May 2024 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Windows进程隐藏初探</title>
      <link>http://localhost:1313/posts/windows%E8%BF%9B%E7%A8%8B%E9%9A%90%E8%97%8F%E5%88%9D%E6%8E%A2/</link>
      <pubDate>Thu, 30 May 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/windows%E8%BF%9B%E7%A8%8B%E9%9A%90%E8%97%8F%E5%88%9D%E6%8E%A2/</guid>
      <description>Windows进程隐藏初探 目的是将我们的进程信息修改，让任务管理器这些无法读取到原本真实的信息，从而做到隐藏效果。比如将目的进程修改成系统进程信息。&#xA;主要使用两个层面隐藏&#xA;R3的PEB中隐藏信息&#xA;R0的_EPROCESS中隐藏信息。&#xA;隐藏我们也可以从两个方面来看，一种是伪造信息，一种是消除信息。伪造信息是指将一个指定进程伪造成其他进程，消除信息是指让任务管理器这种无法读取到这个进程的信息。&#xA;R3隐藏信息 R3伪造信息 我看一些文章主要隐藏信息如下(实际上不止，但是思路是类似的，但是我测试发现没有什么实际上的用处&#xA;程序名称ImageBaseName 命令行参数CommandLine 修改用户组 思路也很简单，获取PEB结构体，然后修改对应字段的内容，这里我用Rust来写，rust调用windows库函数可以参考我之前写的&#xD;文章，这里只写思路和部分代码片段，完整在附录。&#xA;获取本身进程的peb地址，这个很简单，大🔥都知道，读取gs:[60h]&#xA;unsafe { asm!( &amp;#34;mov {0}, gs:[0x60]&amp;#34;, inout(reg) ppeb ); } 如果是将这个代码放在dll中，注入进去需要伪装的进程也可以实现读取peb的效果。但是我这里还是偏向于不使用注入手段，倾向于直接传入进程pid，然后获取peb，这里可以使用ntdll.dll中未导出的函数NtQueryInformationProcess。在rust中可以直接用，c++中需要GetProcAddress(Ntdll, &amp;quot;NtQueryInformationProcess&amp;quot;)来获取&#xA;fn main() { let handle = unsafe { OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, false, 9676) .expect(&amp;#34;[!] OpenProcess error&amp;#34;) }; let mut pbi = PROCESS_BASIC_INFORMATION { ..Default::default() }; let ppbi = &amp;amp;mut pbi as *mut _; let mut return_length = 0u32; unsafe { let _ = NtQueryInformationProcess( handle, ProcessBasicInformation, ppbi as *mut c_void, size_of::&amp;lt;PROCESS_BASIC_INFORMATION&amp;gt;() as u32, &amp;amp;mut return_length, ); println!</description>
    </item>
    <item>
      <title>通过修改物理内存实现跨进程内存读写</title>
      <link>http://localhost:1313/posts/%E9%80%9A%E8%BF%87%E4%BF%AE%E6%94%B9%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E5%AE%9E%E7%8E%B0%E8%B7%A8%E8%BF%9B%E7%A8%8B%E5%86%85%E5%AD%98%E8%AF%BB%E5%86%99/</link>
      <pubDate>Mon, 06 May 2024 11:17:50 +0800</pubDate>
      <guid>http://localhost:1313/posts/%E9%80%9A%E8%BF%87%E4%BF%AE%E6%94%B9%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E5%AE%9E%E7%8E%B0%E8%B7%A8%E8%BF%9B%E7%A8%8B%E5%86%85%E5%AD%98%E8%AF%BB%E5%86%99/</guid>
      <description>跨进程内存读写有多种方式，这里主要了解一下修改物理内存来实现跨进程内存修改方法。这种方法主要是无痕，对比修改cr3来说要无痕的多。&#xA;后面再试试修改cr3和修改MDL映射来做到跨进程内存读写方式。&#xA;系统：win10 21h1 x64&#xA;编译环境: vs2022 详情见附录&#xA;基础 虚拟地址转物理地址 虚拟地址也称线性地址，一个线性地址+进程的DirBase地址可以转换成物理地址。先来看线性地址的含义&#xA;在x64体系中只实现了48位的virtual address，高16位被用作符号扩展，这高16位要么全是0，要么全是1。 不同于x86体系结构，每级页表寻址长度变成9位，由于在x64体系结构中，普通页大小仍为4KB,然而数据却表示64位长，因此一个4KB页在x64体系结构下只能包含512项内容，所以为了保证页对齐和以页为单位的页表内容换入换出，在x64下每级页表寻址部分长度定位9位。&#xA;从Page Map Level 4(PML4)开始到最后的物理地址，每一个都可以理解成一层页表的索引，索引值就是线性地址上不同的部分，分别缩写是PML4, PDPE, PDE,PTE。&#xA;注意，并不是取出来的值就直接指向一下一个页表，个人PC上一般是取值的12-35bit的值，其他置0。具体的后面见代码，或参考&#xD;看雪的文章&#xA;使用windbg可以先查看进程对应的DirBase地址，然后再使用!vtop Dirbase地址 虚拟地址查看虚拟地址对应的物理地址，如下。&#xA;3: kd&amp;gt; !process 258c 0 Searching for Process with Cid == 258c PROCESS ffffc40d2ab48340 SessionId: 1 Cid: 258c Peb: a6e35cd000 ParentCid: 1250 DirBase: 235ae6000 ObjectTable: ffff998138d4ee00 HandleCount: 38. Image: test.exe 3: kd&amp;gt; !vtop 235ae6000 0000A6E334FB00 Amd64VtoP: Virt 000000a6e334fb00, pagedir 0000000235ae6000 Amd64VtoP: PML4E 0000000235ae6008 Amd64VtoP: PDPE 00000001087fb4d8 Amd64VtoP: PDE 000000010f7fc8c8 Amd64VtoP: PTE 00000000ad207a78 Amd64VtoP: Mapped phys 000000011b10cb00 Virtual address a6e334fb00 translates to physical address 11b10cb00.</description>
    </item>
    <item>
      <title>句柄降权绕过CallBacks检查</title>
      <link>http://localhost:1313/posts/%E5%8F%A5%E6%9F%84%E9%99%8D%E6%9D%83%E7%BB%95%E8%BF%87callbacks%E6%A3%80%E6%9F%A5/</link>
      <pubDate>Mon, 29 Apr 2024 22:01:29 +0800</pubDate>
      <guid>http://localhost:1313/posts/%E5%8F%A5%E6%9F%84%E9%99%8D%E6%9D%83%E7%BB%95%E8%BF%87callbacks%E6%A3%80%E6%9F%A5/</guid>
      <description>ObRegistyCallBacks保护指定进程，可以让攻击程序OpenProcess打开指定进程后获取的句柄权限是我们指定的权限范围, 比如不能读取进程内存, 不能终止进程。&#xA;如何绕过这种保护，可以使用句柄降权/提权的方法，就可以对提高已经获取到的句柄权限。&#xA;句柄降权 什么是句柄 当一个进程利用名称来创建或打开一个对象时，将获得一个句柄，该句柄指向所创建或打开的对象。以后，该进程无须使用名称来引用该对象，使用此句柄即可访问。这样做可以显著地提高引用对象的效率。句柄是一个在软件设计中被广泛使用的概念。例如，在C运行库中，文件操作使用句柄来表示，每当应用程序创建或打开一个文件时，只要此创建或打开操作成功，则C运行库返回一个句柄。以后应用程序对文件的读写操作都使用此句柄来标识该文件。而且，如果两个应用程序以共享方式打开了同一个文件，那么，它们将分别得到各自的句柄，且都可以通过句柄操作该文件。尽管两个应用程序得到的句柄的值并不相同，但是这两个句柄所指的文件却是同一个。因此，句柄只是一个对象引用，同一个对象在不同的环境下可能有不同的引用（句柄）值。&#xA;上文中的&amp;quot;对象&amp;quot;指的是内核对象，我们在R3中所使用的文件、进程、线程在内核中都有对应内核对象。应用层每次创建或打开进程、文件都会对相应的内核对象创建一个句柄。当多个进程同时打开一个文件时，该文件在内核中只会存在一个文件内核对象，但每个进程都有一个各自的文件句柄，每个句柄会增加内核对象的引用计数，只有当内核对象的引用计数为0时，内核对象才会释放。&#xA;私有句柄表 eprocess指向一个ObjectTable，ObjectTbale中存在TableCode，这个指向的是这个进程的私有句柄表。同时ObjectTable中还有一个HandleTableList，这个是一个链表，通过HandleTableList 成员遍历得到所有进程的ObjectTable地址&#xA;我们的目标是获取到_object_header结构体，这个结构体才是句柄的真正内容。但是不同版本系统下的取法不太一样，win7是直接指向句柄，win10则需要做一些偏移，这些偏移google没有资料，大多都是通过IDA静态分析函数才能得到。&#xA;win中有一些根据_handle_table_entry获取进程句柄的函数，我这里没有做过多分析，直接使用前辈分析后的经验。分析目标ntoskrnl.exe下的ObpEnumFindHandleProcedure函数，可以看到如下&#xA;__int64 __fastcall ObpEnumFindHandleProcedure( _HANDLE_TABLE *handle_table, _HANDLE_TABLE_ENTRY *handle_table_entry, HANDLE a3, HANDLE *object_header) { unsigned __int8 v5; // bl HANDLE v7; // rbx _DWORD *v8; // rcx __int64 v9; // r11 int v10[10]; // [rsp+0h] [rbp-28h] BYREF if ( !*object_header || *object_header == (HANDLE)((handle_table_entry-&amp;gt;LowValue &amp;gt;&amp;gt; 16) &amp;amp; 0xFFFFFFFFFFFFFFF0ui64) ) { v7 = object_header[1]; if ( !v7 || v7 == (HANDLE)ObTypeIndexTable[(unsigned __int8)ObHeaderCookie ^ *(unsigned __int8 *)(((handle_table_entry-&amp;gt;LowValue &amp;gt;&amp;gt; 16) &amp;amp; 0xFFFFFFFFFFFFFFF0ui64) + 0x18) ^ (unsigned __int64)(unsigned __int8)((unsigned __int16)(WORD1(handle_table_entry-&amp;gt;LowValue) &amp;amp; 0xFFF0) &amp;gt;&amp;gt; 8)] ) { v8 = object_header[2]; if ( !</description>
    </item>
    <item>
      <title>Rust编写几种hook的方式</title>
      <link>http://localhost:1313/posts/rust%E7%BC%96%E5%86%99%E5%87%A0%E7%A7%8Dhook%E7%9A%84%E6%96%B9%E5%BC%8F/</link>
      <pubDate>Fri, 22 Mar 2024 15:59:44 +0800</pubDate>
      <guid>http://localhost:1313/posts/rust%E7%BC%96%E5%86%99%E5%87%A0%E7%A7%8Dhook%E7%9A%84%E6%96%B9%E5%BC%8F/</guid>
      <description>使用Rust编写几种在windows上常用的hook方式:&#xA;IAT hook Inline hook VMT hook 为什么要用rust的不用c++？就是想用，想给自己找麻烦😎&#xA;Rust windows-rs 库使用 早年的教程大多是使用winapi这个库，后来微软官方发布了windows-rs，我就选定用官方的库来做。下面是rust库的一写基础知识&#xA;features 什么是features？&#xA;在安装库的时候大多是时候我们都是cargo add &amp;lt;库名称&amp;gt;安装一整个库，编译的时候也就整个库参与编译，而features则可以进一步选择库中特定的模块，手动在Cargo.toml添加即可&#xA;[dependencies] windows-sys = { version = &amp;#34;0.52.0&amp;#34;, features = [ &amp;#34;Win32_UI_WindowsAndMessaging&amp;#34;, &amp;#34;Win32_System_LibraryLoader&amp;#34;, &amp;#34;Win32_System_Memory&amp;#34;, &amp;#34;Win32_Foundation&amp;#34;, &amp;#34;Win32_System_SystemServices&amp;#34;, &amp;#34;Win32_System_SystemInformation&amp;#34;, &amp;#34;Win32_System_Diagnostics_Debug&amp;#34;, &amp;#34;Win32_Security&amp;#34;, &amp;#34;Win32_System_Threading&amp;#34;, ] } 比如windows-sys就有很多个features，不同的api处于不同的feature下，需要添加后才可以编译&#xA;查看API/结构体对应的fearture&#xA;这个一般要看文档，我这里搜索对应feature是，windows-rs库文档中专门提供了一个搜索api对应feature的地方&#xA;https://microsoft.github.io/windows-rs/features/#/0.53.0&#xA;windows &amp;amp; window-sys&#xA;windows -rs库下有两个版本，一个是windows，一个是windows-sys。区别是sys更底层一些，windows封装的更多一些.&#xA;32位 &amp;amp; 64位 &amp;amp; DLL 在windows上编译32位的需要rustup添加一个交叉编译平台。&#xA;查看所有交叉编译平台&#xA;rustup target list 我是64位 win11，安装一个32的交叉编译&#xA;rustup target add i686-pc-windows-msvc 编译32位程序&#xA;cargo build --target=i686-pc-windows-msvc 如果报错找不到linker，需要在cargo.toml中配置一下linker，根据自己的路径来配置&#xA;[target.i686-pc-windows-msvc] linker = &amp;#34;C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\BuildTools\\VC\\Tools\\MSVC\\14.</description>
    </item>
    <item>
      <title>利用PEB遍历模块链表</title>
      <link>http://localhost:1313/posts/%E5%88%A9%E7%94%A8peb%E9%81%8D%E5%8E%86%E6%A8%A1%E5%9D%97%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Tue, 19 Mar 2024 11:36:56 +0800</pubDate>
      <guid>http://localhost:1313/posts/%E5%88%A9%E7%94%A8peb%E9%81%8D%E5%8E%86%E6%A8%A1%E5%9D%97%E9%93%BE%E8%A1%A8/</guid>
      <description>使用c++, rust实现遍历PEB获取模块信息的代码段. 主要练练rust&#xA;测试环境: win11 23h2 desktop&#xA;编译环境:&#xA;Microsoft Visual Studio Community 2022 版本 17.9.2 VisualStudio.17.Release/17.9.2+34622.214 Microsoft .NET Framework 版本 4.8.09032&#xA;已安装的版本: Community&#xA;Visual C++ 2022 00482-90000-00000-AA003 Microsoft Visual C++ 2022&#xA;ASP.NET and Web Tools 17.9.197.37128 ASP.NET and Web Tools&#xA;Azure 应用服务工具 3.0.0 版 17.9.197.37128 Azure 应用服务工具 3.0.0 版&#xA;C# 工具 4.9.0-3.24121.1+a98c90d56455379836dd5c845b35fa932b00cfa3 IDE 中使用的 C# 组件。可能使用其他版本的编译器，具体取决于你的项目类型和设置。&#xA;Debugging Tools for Windows 10.0.22621.311 Integrates the Windows Debugger functionality (&#xD;http://go.microsoft.com/fwlink/?linkid=223405) in Visual Studio.</description>
    </item>
    <item>
      <title>Rust污点分析调研</title>
      <link>http://localhost:1313/posts/rust%E6%B1%A1%E7%82%B9%E5%88%86%E6%9E%90%E8%B0%83%E7%A0%94/</link>
      <pubDate>Sat, 02 Mar 2024 15:52:25 +0800</pubDate>
      <guid>http://localhost:1313/posts/rust%E6%B1%A1%E7%82%B9%E5%88%86%E6%9E%90%E8%B0%83%E7%A0%94/</guid>
      <description>Rust语言污点分析相关的几篇内容&#xA;SafeDrop: Detecting Memory Deallocation Bugs of Rust Programs via Static Data-flow Analysis. Encapsulated Functions: Fortifying Rust&amp;rsquo;s FFI in Embedded Systems. Demystifying Compiler Unstable Feature Usage and Impacts in the Rust Ecosystem Detecting Cross-language Memory Management Issues in Rust MirChecker: Detecting Bugs in Rust Programs via Static Analysis Static Deadlock Detection for Rust Programs https://e80jag6pyd.feishu.cn/docx/EydXdKtpQoELtdxwA9ycLLDHnOe?from=from_copylink</description>
    </item>
    <item>
      <title>2023 香山杯 Reverse</title>
      <link>http://localhost:1313/posts/2023-%E9%A6%99%E5%B1%B1%E6%9D%AF-reverse/</link>
      <pubDate>Mon, 16 Oct 2023 14:05:44 +0800</pubDate>
      <guid>http://localhost:1313/posts/2023-%E9%A6%99%E5%B1%B1%E6%9D%AF-reverse/</guid>
      <description>香山杯初赛的3到逆向的WP，不是很难的题，但是有一些新的东西，chaquopy框架，这个框架完成了一套sdk，可以安卓调用python代码也可以python调用java代码。可惜的是python是源码存储，还有研究的空间&#xA;URL从哪儿来 题目说明：小A收到一个样本，很轻松就完成了任务：找到样本外联C2。但小A非常好奇的是，他并不能直接在样本中搜到C2，C2是如何被解密的呢？&#xA;题目链接：https://github.com/Military-axe/ctf/tree/master/2023/2023%E9%A6%99%E5%B1%B1%E6%9D%AF%E5%88%9D%E8%B5%9B&#xA;分析，发现有一个程序会导出一个临时文件，临时文件ou.exe才是真正的逻辑所在&#xA;int __cdecl main(int argc, const char **argv, const char **envp) { HMODULE ModuleHandleW; // eax HMODULE v4; // eax HMODULE v5; // eax _BYTE *v7; // [esp+4h] [ebp-28Ch] HGLOBAL hResData; // [esp+8h] [ebp-288h] HRSRC hResInfo; // [esp+Ch] [ebp-284h] _BYTE *lpAddress; // [esp+10h] [ebp-280h] FILE *Stream; // [esp+1Ch] [ebp-274h] DWORD dwSize; // [esp+20h] [ebp-270h] DWORD i; // [esp+28h] [ebp-268h] struct _PROCESS_INFORMATION ProcessInformation; // [esp+30h] [ebp-260h] BYREF struct _STARTUPINFOA StartupInfo; // [esp+40h] [ebp-250h] BYREF CHAR Buffer[260]; // [esp+84h] [ebp-20Ch] BYREF CHAR TempFileName[260]; // [esp+188h] [ebp-108h] BYREF ModuleHandleW = GetModuleHandleW(0); hResInfo = FindResourceW(ModuleHandleW, (LPCWSTR)0x65, L&amp;#34;e_ou&amp;#34;); v4 = GetModuleHandleW(0); hResData = LoadResource(v4, hResInfo); v7 = LockResource(hResData); v5 = GetModuleHandleW(0); dwSize = SizeofResource(v5, hResInfo); lpAddress = VirtualAlloc(0, dwSize, 0x1000u, 4u); if ( !</description>
    </item>
    <item>
      <title>BiAn: Smart Contract Source Code Obfuscation</title>
      <link>http://localhost:1313/posts/bian-smart-contract-source-code-obfuscation/</link>
      <pubDate>Thu, 12 Oct 2023 14:42:18 +0800</pubDate>
      <guid>http://localhost:1313/posts/bian-smart-contract-source-code-obfuscation/</guid>
      <description>智能合约代码混淆，感觉还是ollvm的影子，还是那三种模式，只是做了相关的适配以及加了很多其他细节，总体思路是没有变的。&#xA;创新点在于使用改进后的混沌映射来做不透明谓词，增加了一定的混淆程度&#xA;会议：IEEE Transactions on Software Engineering&#xA;等级：CCF-A&#xA;这篇文章聚焦的领域是智能合约代码混淆，首先说说智能合约代码现状的一些问题。&#xA;首先代码是公开的，不容易及时更改的。是很容易可以反编译得到源码的，这增加了漏洞发现的风险。那么现有的智能合约代码安全方面的工作主要集中在源码级别或者字节码级别的漏洞检测，属于静态分析和动态分析&#xA;本文是从另一个角度增加智能合约代码的安全性，通过混淆代码，减少被漏洞挖掘的可能。同时混淆代码还可以用于保护知识产权（比如在源码中插入验证知识产权的代码，混淆后很难被识别出来并删除）&#xA;混淆从三个角度来混淆&#xA;控制流混淆 数据流混淆 布局混淆 控制流混淆 控制流混淆主要有两个部分，不透明谓词和控制流平坦化&#xA;控制流平坦化 这个是ollvm经典的混淆模式，也是目前在通用领域效果最好的混淆模式之一&#xA;不透明谓词 不透明谓词是生成一些逻辑上永真或者永假效果的复杂表达式，人可以很快分辨出来，但是编译器或者说静态分析器无法推断出这个值，只能在运行时确定。&#xA;y &amp;gt; 10 || x * (x + 1) % 2 == 0这是一个永真式&#xA;插入不透明谓词主要的效果是增加一些虚假的控制流。&#xA;本文提出一种构造不透明谓词的CPM混沌映射来提高不透明谓词的质量。CPM混沌映射基于Chebyshev和PWLCM混沌映射改进，保留混沌映射的敏感和随机性的同时提高了性能&#xA;可以理解CPM混沌映射会生成一个伪随机数范围0-1，每次生成都不一样。论文将混沌映射与不透明谓词结合，关键的等式是生成的伪随机数接近1就为真，接近0则为假。这个可以根据项目开发具体的修改来修改&#xA;数据流混淆 主要就是加密程序中的数据部分。&#xA;通过提取AST语法树中的节点，识别出数据在进行混淆，主要混淆有如下几点&#xA;把局部变量转全局变量 将静态数据转换成动态数据 将整数常数转换成算数表达式 拆分布尔变量：如果原本为true则后续接一个 ||和后续表达式，false则是&amp;amp;&amp;amp;接后续表达式 将标量变量转成向量：在结构体中集体声明整数、布尔、地址、字符串和字节等状态变量，并通过结构体调用成员变量。原有状态变量的所有初始化、赋值和使用都将被相应的结构成员变量替换。替换后的变量名和函数名都是用SHA-1生成原本名称的摘要 布局混淆 主要是对代码中的一些标识符和调试信息增加干扰。&#xA;删除注释，打乱布局：使用无意义的字符串来替换 替换变量名：SHA-1 混淆效果 最后看一下混淆的效果</description>
    </item>
    <item>
      <title>2023 研究生国赛 Reverse</title>
      <link>http://localhost:1313/posts/2023-%E7%A0%94%E7%A9%B6%E7%94%9F%E5%9B%BD%E8%B5%9B-reverse/</link>
      <pubDate>Wed, 27 Sep 2023 23:08:11 +0800</pubDate>
      <guid>http://localhost:1313/posts/2023-%E7%A0%94%E7%A9%B6%E7%94%9F%E5%9B%BD%E8%B5%9B-reverse/</guid>
      <description>4道题做了3到，都不太方便纯静态，动调倒是都挺简单的. 最后一题unity的游戏没什么经验，不知道怎么下手，CE也没下就放弃了&#xA;更新：又看了一下其实unity还是很简单，只是忘记dnspy该展开那个类了，（我说怎么看不到代码呢&#xA;easy_xor 打开ida发现看不全代码&#xA;int __cdecl main(int argc, const char **argv, const char **envp) { int result; // eax char v4; // [esp+0h] [ebp-1CCh] sub_401020(&amp;#34;please input your flag:&amp;#34;, v4); __asm { retn } return result; } 汇编层面发现是利用call $+5，内联了一个没有用的函数，同时加了垃圾指令&#xA;.text:00401560 83 C4 04 add esp, 4 .text:00401563 55 push ebp .text:00401564 E8 00 00 00 00 call $+5 .text:00401564 .text:00401569 .text:00401569 loc_401569: ; DATA XREF: _main+2B↓o .text:00401569 5D pop ebp .</description>
    </item>
    <item>
      <title>2023 羊城杯 Reverse</title>
      <link>http://localhost:1313/posts/2023-%E7%BE%8A%E5%9F%8E%E6%9D%AF-reverse/</link>
      <pubDate>Wed, 06 Sep 2023 17:50:41 +0800</pubDate>
      <guid>http://localhost:1313/posts/2023-%E7%BE%8A%E5%9F%8E%E6%9D%AF-reverse/</guid>
      <description>没打，王哥发了我三题，我就看了一下，稍微多花了时间。&#xA;CSGO 这题golang写的，打开看到一个base64表和密文，直接解码不对，估计换表了，然后有反调试。没怎么找，直接就运行后attach上去&#xA;拿到base表就直接秒了&#xA;vm_co 虚拟机题，不是很难，这是赛后看的，就完整翻译了一遍&#xA;Rip = 0 def function_17(x, y): global Rip if x == 0: Rip = y return f&amp;#34;cmp x, 0\n jz {Rip}&amp;#34; def function_18(x, y): global Rip if x: Rip = y return f&amp;#34;cmp x, 0\n jnz {Rip}&amp;#34; def function_19(x, _): global Rip Rip = x return f&amp;#34;jmp {x}&amp;#34; vm_opcode = { &amp;#34;0&amp;#34;: lambda x, y: f&amp;#34;swap(vm_body[{x}], vm_body[{y}])&amp;#34;, &amp;#34;1&amp;#34;: lambda x, y: f&amp;#34;vm_body[{x}] ^= vm_body[{y}]&amp;#34;, &amp;#34;2&amp;#34;: lambda x, y: f&amp;#34;vm_body[{x}] += {y}&amp;#34;, &amp;#34;3&amp;#34;: lambda x, y: f&amp;#34;vm_body[{x}] += vm_body[{y}]&amp;#34;, &amp;#34;4&amp;#34;: lambda x, y: f&amp;#34;vm_body[{x}] -= {y}&amp;#34;, &amp;#34;5&amp;#34;: lambda x, y: f&amp;#34;vm_body[{x}] -= vm_body[{y}]&amp;#34;, &amp;#34;6&amp;#34;: lambda x, y: f&amp;#34;vm_body[{x}] *= {y}&amp;#34;, &amp;#34;7&amp;#34;: lambda x, y: f&amp;#34;vm_body[{x}] *= vm_body[{y}]&amp;#34;, &amp;#34;8&amp;#34;: lambda x, y: f&amp;#34;vm_body[{x}] = vm_body[{x}] / {y}&amp;#34;, &amp;#34;9&amp;#34;: lambda x, y: f&amp;#34;vm_body[{x}] = vm_body[{x}] / vm_body[{y}]&amp;#34;, &amp;#34;10&amp;#34;: lambda x, y: f&amp;#34;vm_body[{x}] = vm_body[{x}] % {y}&amp;#34;, &amp;#34;11&amp;#34;: lambda x, y: f&amp;#34;vm_body[{x}] = vm_body[{x}] % vm_body[{y}]&amp;#34;, &amp;#34;12&amp;#34;: lambda x, y: f&amp;#34;vm_body[{x}] &amp;lt;&amp;lt;= {y}&amp;#34;, &amp;#34;13&amp;#34;: lambda x, y: f&amp;#34;vm_body[{x}] = vm_body[0] &amp;lt;&amp;lt; {y}&amp;#34;, &amp;#34;14&amp;#34;: lambda x, _: f&amp;#34;vm_body[Var1 + 16] = vm_body[{x}]\n Var1 += 1&amp;#34;, &amp;#34;15&amp;#34;: lambda x, _: f&amp;#34;print(vm_body[{x}])&amp;#34;, &amp;#34;16&amp;#34;: lambda _, __: f&amp;#34;Var1 -= 1\nprint(vm_body[Var + 16])&amp;#34;, &amp;#34;17&amp;#34;: function_17, &amp;#34;18&amp;#34;: function_18, &amp;#34;19&amp;#34;: function_19, &amp;#34;20&amp;#34;: lambda x, _: f&amp;#34;t = vm_body[ vm_body[{x}] ]\n vm_body[Var + 16] = t\nVar += 1&amp;#34;, &amp;#34;21&amp;#34;: lambda _, __: f&amp;#34;Var1 -= 1\n vm_body[0] = vm_body[Var + 16]&amp;#34;, &amp;#34;22&amp;#34;: lambda x, _: f&amp;#34;vm_body[Var + 16] = {x}\nVar += 1&amp;#34;, &amp;#34;23&amp;#34;: lambda _, __: f&amp;#34;if Rip &amp;gt;= 15:\n\tbreak\ncontinue&amp;#34;, &amp;#34;24&amp;#34;: lambda _, __: f&amp;#34;vm_body[0] = vm_body[2] | vm_body[1]&amp;#34;, &amp;#34;25&amp;#34;: lambda x, y: f&amp;#34;vm_body[{x}] = vm_body[0] &amp;gt;&amp;gt; {y}&amp;#34;, &amp;#34;26&amp;#34;: lambda x, y: f&amp;#34;vm_body[{x}] = {y}&amp;#34;, } def interpre_byte_code(opcodes: list, len: int): global Rip Rip = 0 while Rip &amp;lt; len: # print(f&amp;#34;rip =&amp;gt; {Rip}&amp;#34;) print(vm_opcode[str(opcodes[Rip])](opcodes[Rip + 1], opcodes[Rip + 2])) Rip += 3 opcode1 = list(0x20D01011903001A.</description>
    </item>
    <item>
      <title>Rtag cli tools dev</title>
      <link>http://localhost:1313/posts/rtag_cli_tools_dev/</link>
      <pubDate>Fri, 01 Sep 2023 16:15:57 +0800</pubDate>
      <guid>http://localhost:1313/posts/rtag_cli_tools_dev/</guid>
      <description>自己无聊，想开发开发。想着最近需要一个tag管理的系统，我用的是windows的，文件管理是层级管理，不是tag的，想着写一个也不难，就自己写了一下。开发语言用rust，数据库使用mongodb，手很生，写了好几天，累死✌了。&#xA;github地址: https://github.com/Military-axe/rtag&#xA;一个tag管理的系统，为了方便使用tag查找文件使用tag记录对应的值，找个值是文件路径/单纯的值.&#xA;使用mongodb数据库存储数据，rust编程&#xA;安装 编译项目&#xA;cargo build 在target目录下debug下可以找到rtag_data.exe&#xA;源码也可以在其他平台编译，没差的啦&#xA;数据库 集合tags 存在多个文档，一个文档代表一个tag，每个文档中的值如下&#xA;{ &amp;#34;_id&amp;#34;: { &amp;#34;$oid&amp;#34;: &amp;#34;64e714b28054de22d73432e0&amp;#34; }, &amp;#34;tag&amp;#34;: &amp;#34;test&amp;#34;, // tag名称 &amp;#34;value&amp;#34;: [ // 包含此tag的值 &amp;#34;text0&amp;#34;, &amp;#34;text1&amp;#34; ] } 集合values 以values为主的集合，一个values一个文档&#xA;{ &amp;#34;_id&amp;#34;: { &amp;#34;$oid&amp;#34;: &amp;#34;64e714b28054de22d73432e0&amp;#34; }, &amp;#34;value&amp;#34;: &amp;#34;test&amp;#34;, // 值 &amp;#34;tag&amp;#34;: [ // tag &amp;#34;v1&amp;#34;, &amp;#34;v2&amp;#34; ] } 命令行参数 -v/&amp;ndash;value: 目标value -t/&amp;ndash;tag: 目标tag value + tag : 插入值到对应tag中 value: 所有包含字符串的值以及对应的tag tag: 展示有一个tag或者多个tag的值&#xA;-i/&amp;ndash;import: 导入json文件进入数据库中 -e/&amp;ndash;export: 导出数据库内容进入json文件中 添加值和对应的tag 将babyre打上rc4,base64两个不同的tag。或者是更新这个值的tag。</description>
    </item>
    <item>
      <title>Binary Diffing</title>
      <link>http://localhost:1313/posts/binary-diffing-1/</link>
      <pubDate>Sat, 19 Aug 2023 15:56:52 +0800</pubDate>
      <guid>http://localhost:1313/posts/binary-diffing-1/</guid>
      <description>最近想看看binary diffing的内容，直接从头看看一篇篇翻，涉及到很多机器学习内容，很多不懂的，慢慢来看吧。这里先看了10几篇，很多都只看了一个摘要。 主要是了解一下思路，看看这个领域的内容的研究历史，Binary Diffing 1暂时只看到2016年的paper，后续继续更新，主要文章引用如下&#xA;Bitshred: feature hashing malware for scalable triage and semantic analysis. Binary function clustering using semantic hashes. Binslayer: accurate comparison of binary executables. Control flow-based malware variant detection. {MutantX-S}: Scalable Malware Clustering Based on Static Features. Semantics-based obfuscation-resilient binary code similarity comparison with applications to software plagiarism detection. Leveraging semantic signatures for bug search in binary programs. Cross-architecture bug search in binary executables. Bingo: Crossarchitecture cross-os binary search.</description>
    </item>
    <item>
      <title>Khaos: The Impact of Inter-procedural Code Obfuscation on Binary Diffing Techniques</title>
      <link>http://localhost:1313/posts/khao/</link>
      <pubDate>Sun, 23 Jul 2023 21:36:57 +0800</pubDate>
      <guid>http://localhost:1313/posts/khao/</guid>
      <description>这是一篇CCFB的文章，来自中科大，文章提出了一种新的二进制混淆模式来抵抗binary diffing技术的分析。&#xA;从混淆角度，它是从IR层面切割函数并融合函数，改变了函数的调用关系。与OLLVM是不冲突的混淆，对抵抗binary diffing有很好的效果，并且也是基于LLVM框架，对混淆技术的发展是有意义的。&#xA;背景 binary diffing binary diffing是一种识别两个二进制差异的技术，可以通过识别两个二进制之间差异的技术。它可以给出预定义粒度（如函数）的匹配结果。例如bindiff提取了基本块，控制流边和函数调用数量作为函数的特征，然后它节后控制流图匹配算法搜索相似的函数。&#xA;现有的漏洞挖掘方法中，很常见的一个方法是通过对比新旧版本，找出不同处，这些修改处很可能是以及修补的漏洞。通过binary diffing可以快速定位新旧版本中的修改处，从而进一步分析漏洞。现在这种技术常用在分析1day/nday的情况，是一种高效的分析手法&#xA;软件混淆 现在做混淆很多都基于中间指令（IR）来做，比如ollvm的各种魔改。或者做指令虚拟化（VM），但指令虚拟化会导致性能大量损失。所以本文也是对IR做混淆。&#xA;一般现在的IR混淆粒度，都是继承自ollvm的三种粒度。&#xA;指令级：复杂化指令，把一条指令换成多条 基本块级：设置虚假控制流与基本块 函数级：通过函数扁平化，把函数结构转化为难以分析的switch-case结构 随着binary diffing的发展，许多程序内粒度的静态代码重写技术不在有效。主要是程序内代码混淆不会从根本上改变每个函数的语义，而大多数binary diffing都是越来越能提取函数内部特征来理解语义。&#xA;Khaos 设计 Khaos是在IR层面，增加混淆，通过分裂原本的函数，并融合成新的函数。&#xA;oriFunc：原始函数。&#xA;sepFunc：裂变函数，分裂原始函数形成的裂变函数。&#xA;fusFunc：聚变函数，融合后形成的新的函数。&#xA;remFunc：剩余函数，剩余代码形成的函数。&#xA;例子：&#xA;困难 困难1：选择那些基本块或者函数聚合/分离，平衡开销与混淆效果。&#xA;困难2：如何在转换后完全重建函数间的所有控制流&#xA;困难3：简单融合函数，在编译器优化后，混淆效果有限。&#xA;分割形成sepFunc 对代码区域划分转换成一个图形切割问题，函数的控制流图可视为有向图，边的权重代表执行频率，表示冷/热信息。代码区域划分可以看作图的切割，切割边的权重是性能代价，混淆效果是子图中节点的数量。&#xA;基于上述思想提出区域识别算法，来平衡混淆效果与性能&#xA;首先，我们将对函数的支配树进行分析[40]（第 2 行）。&#xA;为了避免将整个函数体分离成一个 sepFunc，我们删除了函数本身的支配者树（第 3 行）&#xA;并从其他树中识别出区域。为了说明裂变对混淆的影响，我们使用树中基本块的数量来表示（第 7 行）。&#xA;为了说明裂变对性能的影响，我们使用块频率分析法来计算支配者树根节点的执行频率（第 8 行），并使用循环次数（如果区域处于循环中，则对 sepFunc 的调用将增加）作为切割的成本（第 8-12 行）。&#xA;我们会反复选择性价比最高（即效果和成本之比最大）的支配树进行分离，直到树集为空（第 13-16 行）。&#xA;数据流重建 除了切割区域作为sepFunc，还需要将函数入口与出口定义出来，也就是这一段带来使用的oriFunc中的局部变量。如果这个变量只有这个sepFunc使用，那么函数参数就可以不要，直接重新在sepFunc中定义局部变量即可。&#xA;控制流重建 把sepFunc在oriFunc中的跳转关系改为call-ret的关系，不同的函数出口返回的基本块也不同（这是与正常返回函数效果不同的地方）。&#xA;对于异常处理控制流，把可能触发异常的代码与catch块放到同一个sepFunc来保证不破坏异常处理的逻辑。&#xA;融合函数 融合函数理论上可以多个函数融合到一起，但是作者从性能角度考虑，选择两个函数融合到一起，融合主要看函数的返回值参数数量与类型是否一致，遵循下面几条原则&#xA;函数变量不确定的不融和，比如printf(....) 函数返回值类型不兼容的不融合 直接调用关系的两个函数不融合 前两个主要满足正确性，最后一个是为了性能考虑，否则很容易产生大量递归的fusFuncs。满足上述条件的sepFuncs将随机成对&#xA;数据流重建 选择完两个函数后，可以很直接的将两个函数合并，然后通过一个ctrl变量来控制数据进入fusFunc的那一部分，如图三中所示。&#xA;同时，由于直接合并两个函数会导致参数数量过多，所以会尝试压缩函数的参数，具体就是会将第一部分中所使用的参数同时运用第二部分相同/类似参数处，如图三的c部分，将原本的参数short a, int m转换成int x，在调用short a中的部分直接(short) x来转换成short类型变量。</description>
    </item>
    <item>
      <title>Obfuscate hide string &amp;&amp; zer0pts</title>
      <link>http://localhost:1313/posts/obfuscate_hide_string_and_zer0pts/</link>
      <pubDate>Mon, 17 Jul 2023 15:43:19 +0800</pubDate>
      <guid>http://localhost:1313/posts/obfuscate_hide_string_and_zer0pts/</guid>
      <description>Obfuscate项目是用于隐藏字符串，增加分析的难度，但是Obfuscate只能对抗静态的分析。zer0pts比赛中的一题就是利用这个项目，但是它很巧妙，隐藏的是模块的函数名，主要逻辑是调用so文件的模块，它隐藏so中的函数名后，从静态分析是很难看出来调用的逻辑是什么，忽然感觉这个项目就有点用了。&#xA;Obfuscate 项目使用 github地址：&#xD;adamyaxley/Obfuscate: Guaranteed compile-time string literal obfuscation header-only library for C++14 (github.com)&#xA;这个项目是对字符串进行加密与解密的一个项目，使用非常简单。&#xA;复制obfuscate.h 到项目中并include进去 封装字符串AY_OBFUSCATE(&amp;quot;My String&amp;quot;) 源码&#xA;#include &amp;lt;iostream&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;#34;obfuscate.h&amp;#34; int main() { const std::string username(AY_OBFUSCATE(&amp;#34;root&amp;#34;)); const std::string password(AY_OBFUSCATE(&amp;#34;password&amp;#34;)); std::cout &amp;lt;&amp;lt; &amp;#34;Obfuscate naive login example (bloat test)&amp;#34; &amp;lt;&amp;lt; std::endl; std::string input_username; std::string input_password; while (true) { std::cout &amp;lt;&amp;lt; &amp;#34;Username: &amp;#34;; std::cin &amp;gt;&amp;gt; input_username; std::cout &amp;lt;&amp;lt; &amp;#34;Password: &amp;#34;; std::cin &amp;gt;&amp;gt; input_password; if (input_username == username &amp;amp;&amp;amp; input_password == password) { std::cout &amp;lt;&amp;lt; &amp;#34;Login success!</description>
    </item>
    <item>
      <title>Frida call java class/method to explode</title>
      <link>http://localhost:1313/posts/frida_call_method_to_explode/</link>
      <pubDate>Fri, 07 Jul 2023 10:01:10 +0800</pubDate>
      <guid>http://localhost:1313/posts/frida_call_method_to_explode/</guid>
      <description>利用Frida去调用java代码中的类，然后爆破。算是一种主动的方法。主要是之前有一道apk题目是爆破的思路，但是我不会写java代码，想起来很难受，冲浪的时候看到&#xD;Sakura的blog有感，就再去试试，并记录在此。然后发现这题原来是adword原题，（其实题目挺简单，只是当时摆），气死✌了。&#xA;主要是记录Frida主动调用apk中Java中的代码。主动调用可以用于爆破，模拟程序部分执行。&#xA;需要注意的知识点是在java代码中的static类型数据在爆破过程中需要每次都对这种类型值重新设置。因为static类型在所有实例中都是统一，修改一个实例就会修改所有实例，需要用变量.属性.value = ...的写法重新设置值。&#xA;var bvar = b.$new(IntClass.$new(2)); for (...) { bvar._static_val.value = ...; } 背景知识 frida捕获异常 有的时候frida卡住，或者直接终止，没有异常显示，需要去捕获异常，调试脚本真的很有用！！其实就是调用js的异常捕获&#xA;try { // 逻辑 } catch(e) { console.log(e); } java类中静态值在爆破中需要修改 在java类中，一个属性如果是static的，不是说这个值不能改，而是说这个属性在程序中是唯一的，无论几个实例，只要改了其中一个实例中static的值，其他实例对应的值也会被改变。&#xA;在爆破过程中，如果需要爆破过程中不停new一个新的类实例，记得看看其中有没有static类型的变量。比如下面的这个例子&#xA;public class b { public static ArrayList&amp;lt;Integer&amp;gt; a = new ArrayList&amp;lt;&amp;gt;(); static String b = &amp;#34;abcdefghijklmnopqrstuvwxyz&amp;#34;; static Integer d = 0; Integer[] c = {8, 25, 17, 23, 7, 22, 1, 16, 6, 9, 21, 0, 15, 5, 10, 18, 2, 24, 4, 11, 3, 14, 19, 12, 20, 13}; public b(Integer num) { for (int intValue = num.</description>
    </item>
    <item>
      <title>Ida Symbolic Recovery</title>
      <link>http://localhost:1313/posts/ida_symbolic_recovery/</link>
      <pubDate>Mon, 03 Jul 2023 21:51:06 +0800</pubDate>
      <guid>http://localhost:1313/posts/ida_symbolic_recovery/</guid>
      <description>最近发现二进制文件中符号恢复的手段有不少，这里想记录一下几种符号恢复的工具使用与效果对比。&#xA;Finger，lscan，flair，bindiff&#xA;编译工具与其他环境 主要是win下的MinGw，VC++，的C和C++和Linux下的GUN/LLVM。主要是针对库函数去符号的一个恢复。&#xA;Finger 阿里出品，很好用，方便。&#xA;github 地址：&#xD;aliyunav/Finger: A tool for recognizing function symbol (github.com)&#xA;实际上是要联网访问阿里的库来识别函数，所以遇到大程序，识别所有函数会慢一点。安装可以看github链接，使用也很简单，ida的导航栏会多一个Finger，两个选项，恢复所有函数或者恢复当前函数。&#xA;绿色的部分是还原的函数名&#xA;这个使用简单，效果好，但是要联网。只是不知道对arm，mips这些其他架构的识别如何。虽然识别可能会有假阳性，但是很低，从易用性来说，这个首选。&#xA;lscan github地址：&#xD;maroueneboubakri/lscan: lscan is a library identification tool on statically linked/stripped binaries (github.com)&#xA;lscan是一个python项目，使用FLIRT（快速库识别和识别技术）签名来进行库识别。也就是通过扫描sig文件，找到与二进制文件最相似的库&#xA;FLIRT 最初是由辛普森 (Peter Silberman) 开发的，后来被 IDA Pro (一种逆向工程工具) 所采用。FLIRT 通过使用一种称为“特征”的字符串来识别库和函数。这些特征是函数中的指令序列，或者是库中使用的函数的调用序列。FLIRT 使用这些特征来生成一个签名数据库，然后可以使用这个数据库来识别二进制文件中使用的库和函数。&#xA;使用&#xA;python ./lscan.py -S .sig的目录 -f 要扫描的二进制文件，例子如下&#xA;python lscan.py -S i386/sig -f i386/bin/bin-libc-2.23 python lscan.py -s i386/sig/libpthread-2.23.sig -f i386/bin/bin-libpthread-2.23 -v python lscan.py -f i386/win32/bin/bin-libcmt.exe -s i386/win32/sig/msvcmrt.</description>
    </item>
    <item>
      <title>Frida learn &amp;&amp; sctf 2023 checkFlow</title>
      <link>http://localhost:1313/posts/frida_learn_and_2023_sctf_check_flow/</link>
      <pubDate>Mon, 03 Jul 2023 16:06:30 +0800</pubDate>
      <guid>http://localhost:1313/posts/frida_learn_and_2023_sctf_check_flow/</guid>
      <description>没有打sctf，但是赛后看NU1L wp时，看到checkFlow这题，师傅用frida调用本身函数来爆破。虽然这种爆破要求本身函数状态不受运行的影响，但还是很好的做法。这种做法一直都有，只是我一直没去了解，这次看到这个，就学习一下&#xA;frida hook 函数 平时看frida hook函数都是在android中，这里主要还是在elf和pe上。&#xA;下面的脚本是frida attach到进程上，并捕获对应函数，函数给地址就可以，当函数指针一样。然后将值打印出来。&#xA;import frida import sys session = frida.attach(&amp;#34;hello&amp;#34;) script = session.create_script(&amp;#34;&amp;#34;&amp;#34; Interceptor.attach(ptr(&amp;#34;%s&amp;#34;), { onEnter(args) { send(args[0].toInt32()); } }); &amp;#34;&amp;#34;&amp;#34; % int(sys.argv[1], 16)) def on_message(message, data): print(message) script.on(&amp;#39;message&amp;#39;, on_message) script.load() sys.stdin.read() 命令行传入需要hook的函数的地址。可以gdb attach进去看再detch出来。或者关掉pie自己算一下偏移。&#xA;捕获函数指针并调用可以这么写&#xA;import frida import sys session = frida.attach(&amp;#34;hello&amp;#34;) script = session.create_script(&amp;#34;&amp;#34;&amp;#34; const f = new NativeFunction(ptr(&amp;#34;%s&amp;#34;), &amp;#39;void&amp;#39;, [&amp;#39;int&amp;#39;]); f(1911); f(1911); f(1911); &amp;#34;&amp;#34;&amp;#34; % int(sys.argv[1], 16)) script.load() 用new NativeFunction(ptr(&amp;quot;%s&amp;quot;), &#39;void&#39;, [&#39;int&#39;])来捕获，第一个参数是函数指针，第二个是返回值，第三个是函数的参数类型列表。</description>
    </item>
    <item>
      <title>2023 Two Reverse CrackMe WriteUp</title>
      <link>http://localhost:1313/posts/%E5%A4%A9%E8%9E%8D%E4%BF%A1wp/</link>
      <pubDate>Fri, 30 Jun 2023 17:05:32 +0800</pubDate>
      <guid>http://localhost:1313/posts/%E5%A4%A9%E8%9E%8D%E4%BF%A1wp/</guid>
      <description>前几天打了一个应该是天融信的比赛，题目不难，简单记录一下。&#xA;一道是花指令+rc4，一道是mov混淆&#xA;junk 这题是简单的花指令+rc4&#xA;打开题目后看到&#xA;这是经典的jz,jnz的花指令。只需要将第一个跳转指令换成jmp就可以。这里选择用idapython写一个脚本来去花&#xA;from ida_bytes import patch_bytes, get_bytes address = 0x4010C7 length = 0x10000 ptr = address while address+length &amp;gt;= ptr: if get_bytes(ptr,3) != b&amp;#39;\x0f\x84\x09&amp;#39; or get_bytes(ptr+6, 3) != b&amp;#39;\x0f\x85\x03&amp;#39;: ptr += 1 continue patch_bytes(ptr, b&amp;#39;\xeb\x0d\x90\x90\x90&amp;#39;) ptr += 12 然后将所有代码取消定义再重新解析，然后选中main开头到结尾，定义函数。在F5就可以看到代码了&#xA;int __cdecl main(int argc, const char **argv, const char **envp) { char v4; // [esp+0h] [ebp-160h] char v5[256]; // [esp+30h] [ebp-130h] BYREF char Buf1; // [esp+130h] [ebp-30h] BYREF _BYTE v7[3]; // [esp+131h] [ebp-2Fh] BYREF int v8[2]; // [esp+150h] [ebp-10h] BYREF char v9; // [esp+158h] [ebp-8h] memset(v5, 0, sizeof(v5)); v8[0] = -272716322; v8[1] = 2018915346; v9 = 0; sub_401050(&amp;#34;%29s&amp;#34;, &amp;amp;Buf1); sub_401080(v5, v8, (char *)v8 + strlen((const char *)v8) + 1 - ((char *)v8 + 1)); sub_4011F0(v5, &amp;amp;Buf1, &amp;amp;v7[strlen(&amp;amp;Buf1)] - v7); if ( !</description>
    </item>
    <item>
      <title>KextFuzz Fuzzing macOS Kernel EXTensions on Apple Silicon via Exploiting Mitigations</title>
      <link>http://localhost:1313/posts/kextfuzz/</link>
      <pubDate>Wed, 14 Jun 2023 15:53:46 +0800</pubDate>
      <guid>http://localhost:1313/posts/kextfuzz/</guid>
      <description>来自清华vul337实验室与蚂蚁基础安全合作的一篇2023年USENIX Security的文章&#xA;讲述如何针对macOS内核部分的kext进行模糊测试，原本kext是闭源的部分，同时处于内核。这使得插桩难，容易崩溃，黑盒测试效果差。同时苹果本身一些特权代码被保护。文章针对这些问题提出三个机制来解决&#xA;通过替换arm的PA指令来插桩，做覆盖率统计；通过本地hook特权检查函数来绕过苹果的检查，进一步fuzz特权代码；设计一个污点分析模块，分析macOS内核接口格式，辅助fuzz&#xA;背景与困难 macOS的内核中有很大一部分是KEXT(Kernel Extension)，可以直接当作Linux中的驱动。但是在mac中是闭源的。由于闭源，分析难度高，所以漏洞挖掘与测试不充分，这也使得kext成为主要的攻击面。 但是对kext fuzz有3方面的问题&#xA;怎么采集代码覆盖率：Coverage 反馈是提升 fuzz 效率的基本手段。其采集方法通常有代码插桩（kcov）、硬件监听（Intel-PT）与虚拟层监听（AFL-qemu）几种方式。但是三种方法都不使用kext. 源码插桩无法适用闭源组件，binary rewriting的闭源插桩具有一定可行，但是内核中使用这种插桩很容易系统崩溃，不使用与内核；apple silicon不提供Intel-PT 相似的硬件监听功能；Apple Silicon macOS 系统虚拟化技术仍不成熟，虚拟化环境能够支持的 kext 十分有限。 如何识别接口格式：能准确得到接口格式，对fuzz数据的生成有更好的帮助，但是闭源程序信息少，macOS驱动接口又复杂，大量不同种类与格式的输入。 如何绕过权限检查：macOS 驱动广泛使用 Entitlement 检查限制能够调用驱动的用户态程序，而大部分 Entitlement 仅分配给苹果公司或部分特殊开发者（如大型公司），包括 Fuzzer 在内的普通第三方程序难以获取，这限制了 Fuzzer 能够触发的代码范围。然而，在实战中，攻击者仍然可以通过构造攻击链，利用受保护代码中的漏洞，使得受 Entitlement 保护的特权代码成为了一个缺少测试的独特攻击面。 统计代码覆盖率 kext在统计代码覆盖率上使用的还是binary rewriting实现代码覆盖率插桩。直接加入指令会造成原有指令便宜，很容易破坏原有程序（静态分析修复可以修复一部分，但是也难以全面），在内核环境下不适用。 kext中使用了ARM的一个PA（Pointer Authentication）机制，这个机制是插入一些指令来保证控制流完整，这些指令会提高漏洞利用的难度，但是对于fuzz来说这些指令是没有实际作用的，同时不对正常功能有影响。所以作者直接去除这些PA指令，用这些指令的位置来添加插桩的代码。&#xA;接口识别 kext用户态的调用很规范，所以可以通过静态污点分析来分析用户态调用kext接口片段代码，从而分析出接口参数格式。KextFuzz设计了一个多标签静态五点方法来分析kext用户空间包装器代码。&#xA;macOS为内核服务提供了抽象层，其中的组件将复杂的kext调用封装成良好的服务，并以标准的方式与kext互动。但是这些包装器也是闭源的，所以还是得二进制文件静态污点分析来还原出来。&#xA;KextFuzz建立了调用kext接口(\(I\))的函数(\(F\))的控制流程图(CFG)。然后，KextFuzz提取了从\(F\)的函数入口开始到\(I\)结束的路径(\(\lambda\))作为分析目标，也就是上图 污点分析定义污点源&#xA;kext接口的输出(\(s1\))：一些kext接口使用其他接口的输出作为输入，这些值要求很精确，很难通过突变产生，所以通过这个标签来识别 全局变量(\(s2\)) 对象创建函数返回值(\(s3\)) ：有一些参数是一些特别的对象，这些对象很复杂，由特殊的API创建，所以识别这些函数，在函数的返回值上打上标记。 栈和堆的指针(\(s4\))：在堆栈寄存器（SP，arm64的x29）和内存分配函数的返回值上添加污点标签 调用者函数参数(\(s5\))：c++开发的二进制文件在导入外部函数时，函数名是经过命令粉碎（name mangling）机制的，此时外部函数的参数信息也会在命名上得到显示，如果\(I\)接口调用函数\(F\)的参数，那也可以用于识别，所以在\(F\)的参数上识别 权限过滤器 权限保护敏感功能不被普通用户调用，只有授权的公司和产品才能调用，这也增加了测试的难度，使得这些代码缺乏测试。KextFuzz自动像攻击者一样绕过这部分检查。 kexts调用检查函数来检查权限（这部分函数由 macOS XNU和AMFI kext实现）。需要被检查kexts（也就是外部驱动）需要调用外部的kexts检查函数。 KextFuzz通过二进制重写来hook检查器函数来劫持权限检查。&#xA;在57个有权限检查的kexts中，有8个与安全有关，9个与系统管理有关，使用权限过滤器成功绕郭权限检查，并使用kextFuzz发现了18个特权代码漏洞。&#xA;KextFuzz 结构 binary rewriting 模拟执行的污点 使用Triton作为污点分析引擎。由于只分析代码片段，所有有两个问题&#xA;如何初始化寄存器和内存 对于其他调用函数怎么分析？尤其是创建CoreFoundation对象的函数，这些函数提供了参数类型信息？ KextFuzz使用特殊的值来初始化程序状态。同时必须在分析开始前对函数参数和堆栈指针初始化，对应就是\(s4,s5\)&#xA;初始化寄存器与内存 在初始化中使用的特殊值被编码，如图6所示。KextFuzz将寄存器和内存分为32位单元。在每个单元中，KextFuzz使用高位来记录污点来源和详细信息（例如，函数和参数索引）。 它还记录了嵌套级别以识别指针。嵌套级别指的是访问该值所需的解除引用次数。指针使用零级。它们所指向的内存块使用第一级，进一步说，第二级和第三级。 在执行之前，KextFuzz初始化了寄存器和内存，如图6所示。参数以及它们所指向的内存都是用\(s5\)标签初始化的。因此，污点标签不会在指针解除引用时丢失。 macOS中的封装二进制文件主要是用C++开发的，所以KextFuzz认为存储在X0中的F的第一个参数是一个THIS变量指针，它可以被看作是一个全局变量，需要使用标签\(s2\)。</description>
    </item>
    <item>
      <title>2023 ciscn ezbytes Write Up</title>
      <link>http://localhost:1313/posts/2023_ciscn_ezbytes/</link>
      <pubDate>Sun, 11 Jun 2023 15:40:13 +0800</pubDate>
      <guid>http://localhost:1313/posts/2023_ciscn_ezbytes/</guid>
      <description>这题使用了DWARF字节码，需要了解DWARF相关知识，实际上是c++异常处理中的相关知识。这题利用异常处理的栈回溯，执行了一段设计好的DWARF字节码，单纯的跟踪是跟踪不到的&#xA;这题怪我没有心去做这题，不然早就出了，最近想改变一下心态，既然不能摆脱，那就走到底。&#xA;c++异常处理 根据 c++ 的标准，异常抛出后如果在当前函数内没有被捕捉(catch)，它就要沿着函数的调用链继续往上抛，直到走完整个调用链，或者在某个函数中找到相应的 catch。 程序中的 catch 那部分代码有一个专门的名字叫作：Landing pad（不十分准确），从抛异常开始到执行 landing pad 里的代码这中间的整个过程叫作 stack unwind（栈展开），这个过程包含了两个阶段：&#xA;从抛异常的函数开始，对调用链上的函数逐个往前查找 landing pad。 如果没有找到 landing pad 则把程序 abort，如果找到则记下 landing pad 的位置，再重新回到抛异常的函数那里开始，一帧一帧地清理调用链上各个函数内部的局部变量，直到 landing pad 所在的函数为止。 简而言之，正常情况下，stack unwind 所要做的事情就是从抛出异常的函数开始，沿着调用链向上找 catch 所在的函数，然后从抛异常的地方开始，清理调用链上各栈帧内已经创建了的局部变量。&#xA;void func1() { cs a; // stack unwind时被析构。 throw 3; } void func2() { cs b; func1(); } void func3() { cs c; try { func2(); } catch (int) { //进入这里之前， func1, func2已经被unwind. } } 这里可以看到unwind的调用过程是函数调用的逆过程，实际实现的过程由专门的 stack unwind 库来进行。</description>
    </item>
    <item>
      <title>PyFET: Forensically Equivalent Transformation for Python Binary Decompilation</title>
      <link>http://localhost:1313/posts/pyfet/</link>
      <pubDate>Sat, 10 Jun 2023 21:12:15 +0800</pubDate>
      <guid>http://localhost:1313/posts/pyfet/</guid>
      <description>2023 S&amp;amp;P论文，讲述的是python反编译的研究工作，总结了大量的反编译特征，针对恶意代码分析领域，提供一种新的解决方案。 从逆向和工程的角度来说，这项工作有很多值得学习的部分。&#xA;论文主旨 困难点 python代码编译成pyc或者可执行文件后，对于反编译会出现困难，尤其是刻意加了混淆指令的python程序。以往遇到反编译失败，只能通过人工分析的方法，成本非常高昂，因为python的反编译只有几个，没有其他折中的选择。&#xA;作者思路 从分析恶意脚本出发，以往的角度都是完全还原源代码，往精准的反编译上靠拢，本文提出&#xA;对于分析中很多不重要的部分，可以去除，或者替换指令，来降低反编译难度 反编译过程中遇到报错，通过FET模式匹配修复后继续反编译，使得能够自动反编译完成。 无论是分析python编译后结构中可替换部分结构，还是反编译报错解决都需要大量的特征收集，从工程上本文的关键是数据收集，从研究角度上本文最大的贡献是提出无需精确还原，采用替换部分结构，为恶意代码分析之类对代码恢复的精确性不是那么敏感的工作（其实就是背后有大量人工投入嘛~）添砖加瓦。&#xA;项目细节 在逆向分析的时候并不一定追求精确还原代码（即保证反编译结果的语义正确性），所以我们完全可以做一些妥协，把一些不好处理的地方简化掉或者修改掉，使得decompiler能够工作下去。&#xA;去除部分关键字 在逆向时，如果没有这些关键字，我们还是理解语义&#xA;转换控制逻辑结构 去掉部分结构或者替换成一些简单的结构是可行的&#xA;添加空操作指令 python本身具有一个NOP操作指令，但是现有的反编译器无法识别和翻译这个指令。次项目实现了类似的空操作指令，是得反编译器能翻译和识别。 空操作指令的用处是&#xA;替换一些不重要的指令 对齐已经替换的指令 PYFET结构 主要有两个组成部分，错误识别，迭代转换自动解决检测到的错误&#xA;定位错误 通过来自反编译器的错误信息来定位错误位置，如果没有错误信息但是又反编译失败了则不认为是显性错误，可以查看下面的隐性错误。报错信息的模式如下&#xA;处理隐性错误 处理隐性错误的流程。 如果识别出一个与隐形错误匹配的代码片段，则对照隐性错误，得到两个值，一个是原本的可能为隐形错\(S_{error}\)一个是对照后可能的正确模式\(S_{correct}\).将这两个源码重新编译一遍（同一个编译器），得到\(I_{error}, I_{correct}\)。然后回到原二进制文件中对应的位置，看匹配\(I_{error}, I_{correct}\)中哪一个，从而发现隐性错误，继续反编译。&#xA;常见的隐形错误模式的修复前后对比，这里只显示6组。&#xA;迭代转换 首先获取cfg，并选择包含错误位置的目标块 对目标块中的指令进行转换 对转换后的结果，运行错误识别来检查转换后的是否解决最初的目标错误，如果没有成功会找当前块的邻近块来反复执行这个过程。 当没有目标块可以处理，也没有找到成功的转换的时候，就失败 上图的例子就是0块发生错误，但是无法通过转换来解决，这时候首先找到与0块直接相连的几个1块，通过尝试转换，1块任然不行再拓展到2块。已经解决过的块是不会再加入这个流程，直接解决问题或者没有其他块了。下面是基本块选择算法。&#xA;从工程角度看一下细节，其中对于指令的匹配和替换是使用正则表达式和定义了一些转换规则。 正则表达式是匹配指令链&#xA;上图表示匹配一个POP_JUMP_IF_FALSE,POP_JUMP_IF_TRUE指令链加一个跳转块，再RE-1这种情况下会直接第三列的结果，RE-2没有匹配成功就不改变，RE-3对应的情况和RE-1不同，考虑下面这种情况&#xA;这种if语句超过三个参数，不再只有两个块，所以使用RE-1是不行的，需要多个块都跳转。也就是通过正则匹配指令链和参数后，根据不同情况，每种指令链都有多个可能情况需要对应。&#xA;实验评估 反编译效果验证 收集了38351个不同的python恶意样本，选取了现有的5中反编译器Uncompyle6, Decompyle3, Uncompyle2, Unpyc37, and Decompyle++，确定17117个样本（45.6%）反编译失败&#xA;使用这17117个样本去验证本项目的有效性，PYFET成功解决了所有的反编译错误 下表显示了样本中隐性和显性错误的数量。&#xA;正确性验证 选择了100个流行python程序的源码，和二进制文件，总计14949个python文件。然后对30个FET规则选择40个对应报错，总共1200个反编译错误的样本。 对每个错误样本，将FET的结果手动应用在源码上，然后编译为样本，得到1200个源码转换后的样本。 然后对1中1200二进制文件，直接用PYFET转化，得到1200个转化后的二进制文件 对比2中的二进制样本和3中的二进制样本，结果显示没有字节码上的差异，意味着pyfet所有的转换都是正确的。&#xA;采用这种验证方法是因为，直接FET反编译过来中间优化或者去除了部分逻辑，不能执行的，无法对比一个正确性，所以作者正对每一个转化规则，选取了40个不同的报错，每个报错根据FET规则，在源码上手动修改，再编译。和直接用PYFET修改后的二进制对比，说明PYFET直接转发二进制程序反编译后和源码上直接应用FET规则是一样的效果。 但是由于其中有人工的部分，这一部分实验数据存疑。&#xA;转换的影响 100%的反编译率+100%的正确性，给作者他也不敢开这个口，于是他加了一个实验。 将3中的结果反编译成源码，对比项目原本的源码，结果显示，在源码层面，pyfet影响平均不到3行源码。（这看起来稍微靠谱了一点&#xA;对抗PjOrion与opcode remap python技术 opcode remap python 这是通过修改python源码，改变指令对应的opcode值，这样正常的反编译器是无法反编译成功的。文中以Dropbox的反编译为例子讲述如何使用PYFET反编译. 首先Dropbox是基于python3.8.12版本的python，所以作者先编译python 3.</description>
    </item>
    <item>
      <title>Driver Development and Debug Config</title>
      <link>http://localhost:1313/posts/driver_development_and_debug_config/</link>
      <pubDate>Thu, 08 Jun 2023 13:58:36 +0800</pubDate>
      <guid>http://localhost:1313/posts/driver_development_and_debug_config/</guid>
      <description>配置windows驱动开发环境与windbg preview调试技巧，还会记录一下遇到的问题&#xA;驱动开发 我选择的模式是物理机编译开发驱动，虚拟机调试&#xA;开发环境 开发环境：vs2019 + vscode&#xA;选择vs2019的原因是我用vs2022，配置wdk和sdk后，模板中没有minifilter，刚好又是我要用的，只能选择vs2019. 如果有师傅解决了这个问题麻烦mail我，感激不尽.&#xA;sdk version: 10.0.19041 wdk version: 10.0.19041, WDK 版本和其他下载&#xA;wdk和sdk版本务必一样，查看wdk是下载下来后，点击安装在安装界面的上边可以看到，我这里是已经安装了所以报错&#xA;项目设置 根据vs2019的配置与需求配置项目，配置都是在project-&amp;gt;properties中设置，不一定按照这个配置，这个配置是为了开发时候方便调试，一切从简。从上线项目的角度来看，不建议开启下面的，但是我测试项目，上线再说。&#xA;c++-&amp;gt;General-&amp;gt;Treat Warnings As Err设置为 No c++-&amp;gt;Code Generation-&amp;gt;Spectre Mitigation设置Disable Linker-&amp;gt;General-&amp;gt;Treat Warnings As Err设置为No Driver-&amp;gt;Settings-&amp;gt;Target OS version设置为Windows 10 or higher，因为我的虚拟机是win10 Configuartion选择Debug，没有证书别选release，否则安装不上 这些都是vs2019中用于编译的，我开发代码是用vscode，写完了再去vs2019点一下编译，直接用vscode打开项目会很多头文件缺失，补全也很简单，在项目目录下配置一下。&#xA;vscode control+shift+p打开控制面板，选择C/C++ Edit Configuration(JSON)，然后在vs2019右键引用在vscode中缺失的头文件，copy一下路径，配置在vscode的项目json中。实际上只用添加一个路径，我这是&amp;quot;C:/Program Files (x86)/Windows Kits/10/Include/10.0.19041.0/km&amp;quot;&#xA;{ &amp;#34;configurations&amp;#34;: [ { &amp;#34;name&amp;#34;: &amp;#34;Win32&amp;#34;, &amp;#34;includePath&amp;#34;: [ &amp;#34;${workspaceFolder}/**&amp;#34;, &amp;#34;C:/Program Files (x86)/Windows Kits/10/Include/10.0.19041.0/km&amp;#34; ], &amp;#34;defines&amp;#34;: [ &amp;#34;_DEBUG&amp;#34;, &amp;#34;UNICODE&amp;#34;, &amp;#34;_UNICODE&amp;#34; ], &amp;#34;windowsSdkVersion&amp;#34;: &amp;#34;10.0.22000.0&amp;#34;, &amp;#34;compilerPath&amp;#34;: &amp;#34;cl.</description>
    </item>
    <item>
      <title>2023 XCTF GotYouKey Write Up</title>
      <link>http://localhost:1313/posts/gotyoukey/</link>
      <pubDate>Wed, 07 Jun 2023 13:37:53 +0800</pubDate>
      <guid>http://localhost:1313/posts/gotyoukey/</guid>
      <description>前些天没做出来的题目，后面再思考后发现了自己忽略so文件中调用java代码，赛后做了出来整理在此。&#xA;分析过程 jadx反编译后看源码，前面都是开线程，开端口，都不关键，直接到com.hack.gotyourkey.Oooo000中看到关键函数 只有这个check函数关键其他的都是加的，传入check函数中的就是输入的值。 进入之后是AES加密和base64换表 接出来得到flag: flag{345ghyuj!$}&#xA;from Crypto.Cipher import AES import base64 str1 = &amp;#34;UGCA3QBFjPnlAZ6-NbV2Ca^^&amp;#34; string1 = &amp;#34;abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-+^&amp;#34; string2 = &amp;#34;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=&amp;#34; key = b&amp;#39;1234567890abcdef&amp;#39; c = base64.b64decode(str1.translate(str.maketrans(string1,string2))) e = AES.new(key, AES.MODE_ECB) m = e.decrypt(c) print(m) 但是这个flag是假的，继续分析后发现，存在一个libgotyoukey.so 打开后在JNI_OnLoad函数存在很多逻辑 进入core函数后，设置第一个参数为JNIEnv * 可以发现core中的函数是调用各种java中的函数，还原函数类型后，重命名后逻辑如下&#xA;v54 = FindClass(env, &amp;#34;android/app/ActivityThread&amp;#34;); v53 = GetStaticFieldID(env, v54, &amp;#34;sCurrentActivityThread&amp;#34;, &amp;#34;Landroid/app/ActivityThread;&amp;#34;); v52 = GetFieldID(env, v54, &amp;#34;mInitialApplication&amp;#34;, &amp;#34;Landroid/app/Application;&amp;#34;); v51 = GetStaticObjectField(env, v54, v53); v50 = GetObjectField(env, v51, v52); v49 = FindClass(env, &amp;#34;android/app/Application&amp;#34;); v48 = GetMethodID(env, v49, &amp;#34;getAssets&amp;#34;, &amp;#34;()Landroid/content/res/AssetManager;&amp;#34;); v47 = CallObjectMethodV(env, v50, v48); v46 = FindClass(env, &amp;#34;android/content/res/AssetManager&amp;#34;); v45 = GetMethodID(env, v46, &amp;#34;openFd&amp;#34;, &amp;#34;(Ljava/lang/String;)Landroid/content/res/AssetFileDescriptor;&amp;#34;); v44 = NewStringUTF(env, &amp;#34;asset.</description>
    </item>
  </channel>
</rss>
